<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>ZTap-Arena — Deep-Space Nebula+ v7</title>
<style>
  html,body{margin:0;height:100%;background:#06080f;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;color:#e6f0ff}
  canvas{display:block;width:100vw;height:100vh;touch-action:none;cursor:crosshair}
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
// ===== Canvas setup =====
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha:false });
const isMobile = /Mobi|Android|iPhone/i.test(navigator.userAgent);
let W=1,H=1,DPR=1,UIS=1;
function resize(){
  const vw = Math.max(1, document.documentElement.clientWidth || innerWidth || 320);
  const vh = Math.max(1, document.documentElement.clientHeight || innerHeight || 240);
  DPR = isMobile ? Math.min(2, (window.devicePixelRatio||1)) : (window.devicePixelRatio||1);
  W = (vw*DPR)|0; H = (vh*DPR)|0;
  canvas.width=W; canvas.height=H;
  canvas.style.width=vw+'px'; canvas.style.height=vh+'px';
  UIS = Math.min(1, Math.max(0.8, Math.min(vw,vh)/720));
  initBackdrop();
}
addEventListener('resize', resize, {passive:true});

// ===== RAF guard + visibility pause =====
let _rafId=0;
let _paused=false;
document.addEventListener('visibilitychange',()=>{ _paused=document.hidden; });

function showError(msg){ try{ ctx.setTransform(1,0,0,1,0,0); ctx.fillStyle='#220'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#fbb'; ctx.fillText('⚠ '+String(msg).slice(0,200), 10*DPR, 20*DPR);}catch(_){} }
addEventListener('error',e=>showError(e.message||e.error));
addEventListener('unhandledrejection',e=>showError(e.reason));

// ===== Game state =====
const COMBO_WINDOW = 1800;
const OVERDRIVE_COMBO = 20;
const OVERDRIVE_MS = 6000;

const state={
  time:0, shake:0, hitstop:0,
  score:0, displayScore:0, scorePulse:0,
  lives:3, wave:1, gameOver:false,
  enemies:[], bullets:[], enemyShots:[],
  stars:[], nebula:[], galaxies:[], comets:[],
  trails:[], ripples:[], floaters:[], particles:[], powerups:[],
  lastSpawn:0, spawnDelay:650, waveTarget:12, spawned:0,
  lastShot:0, shootDelay:380,
  activePointers:new Set(), lastTapTime:0, lastTapX:0, lastTapY:0,
  bombs:1, invuln:0,
  spreadLevel:0, hasteTimer:0,
  mult:1, multTimer:0, multCap:3, geomCapReached:false,
  banner:{text:'',t:0},
  joy:{ active:false, ox:0, oy:0, x:0, y:0, a:0, t:0 },
  cometTimer: 0, bgPulse: 0,
  combo:0, comboTimeMs:0, comboBest:0,
  magnet:0, tookHitThisWave:false,
  comboPulse:0, comboMilestone:0,
  overdrive:false, overdriveTimer:0, overdrivePulse:0,
  // v6 augment scaffolding retained (for future)
  aug:{speedMul:1, bulletSpeedMul:1, playerSizeMul:1, comboWindowBonus:0, overdriveComboDelta:0, overdriveMsBonus:0, magnetBoost:0},
  choice:{active:false, options:[], picked:null},
  bounties: [],
  // v7 additions
  magnetBoostTimer:0,
  bestScore: Number(localStorage.getItem('ztap_best')||0),
  justStarted:true
};

const player={ x:0,y:0, tx:0,ty:0, r:16, speed:0.38, color:'#00ffcc' };

// ===== Utils =====
const rand=(a,b)=>a+Math.random()*(b-a);
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
function segHitsCircle(x1,y1,x2,y2,cx,cy,r){
  const dx=x2-x1, dy=y2-y1; const a=dx*dx+dy*dy;
  if(a===0){ return Math.hypot(cx-x1, cy-y1) <= r; }
  let t=((cx-x1)*dx + (cy-y1)*dy)/a; if(t<0) t=0; else if(t>1) t=1;
  const px=x1 + dx*t, py=y1 + dy*t; return Math.hypot(px-cx,py-cy) <= r;
}
function drawStar(x,y,points,outerR,innerR,rot){ ctx.beginPath(); rot=rot||-Math.PI/2; const step=Math.PI/points; for(let i=0;i<points*2;i++){ const r=(i%2===0? outerR:innerR); const a=rot+i*step; const sx=x+Math.cos(a)*r, sy=y+Math.sin(a)*r; i?ctx.lineTo(sx,sy):ctx.moveTo(sx,sy);} ctx.closePath(); }

// ===== Backdrop init =====
function initBackdrop(){
  const starCount=Math.max(90,Math.floor((W*H)/11000)); const stars=[];
  for(let i=0;i<starCount;i++) stars.push({x:Math.random()*W,y:Math.random()*H,z:Math.random()<0.6?0.5:1,tw:Math.random()*6});
  state.stars=stars;
  const N=[]; const base=[{x:W*0.30,y:H*0.35,r:120*DPR,color:'rgba(100,160,255,0.10)'},{x:W*0.72,y:H*0.62,r:160*DPR,color:'rgba(100,160,255,0.08)'}];
  const extra=[{x:W*rand(0.2,0.4),y:H*rand(0.2,0.5),r:rand(90,150)*DPR,color:'rgba(190,110,255,0.16)'},{x:W*rand(0.6,0.85),y:H*rand(0.45,0.8),r:rand(120,180)*DPR,color:'rgba(255,170,90,0.14)'},{x:W*rand(0.35,0.65),y:H*rand(0.15,0.4),r:rand(100,160)*DPR,color:'rgba(90,230,220,0.16)'}];
  [...base,...extra].forEach((n,i)=>{ N.push({x:n.x,y:n.y,r:n.r,baseR:n.r,color:n.color,phase:rand(0,Math.PI*2),speed:rand(0.0007,0.0012)}) });
  state.nebula=N;
  const G=[]; const makeG=z=>({x:rand(W*0.15,W*0.85),y:rand(H*0.15,H*0.85),z,rot:rand(0,Math.PI*2),rotSpeed:rand(0.0002,0.0005),rx:rand(160,260)*DPR,ry:rand(80,160)*DPR,hue:rand(180,330)});
  G.push(makeG(0.35)); G.push(makeG(0.6)); state.galaxies=G;
  state.cometTimer = rand(12000,22000);
}

// ===== Background draw =====
function waveGradient(){ return state.overdrive?['#101b3b','#070a12']:['#0b1020','#05070a']; }
function drawBackground(){
  const pulse=Math.max(0,state.bgPulse||0), boost=1+0.5*pulse;
  const [c0,c1]=waveGradient(); const g=ctx.createRadialGradient(W/2,H/2,0,W/2,H/2,Math.max(W,H)/1.05);
  g.addColorStop(0,c0); g.addColorStop(0.55,state.overdrive?'#1a2550':'#0f1730'); g.addColorStop(1,c1);
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
  ctx.save(); for(const gal of state.galaxies){ const parx=(player.x-W/2)*0.00025*(gal.z*60), pary=(player.y-H/2)*0.00025*(gal.z*60); const x=((gal.x+parx)%W+W)%W, y=((gal.y+pary)%H+H)%H; ctx.save(); ctx.translate(x,y); ctx.rotate(gal.rot); ctx.scale(gal.rx,gal.ry); const rg=ctx.createRadialGradient(0,0,0,0,0,1); const h=gal.hue; const amp=state.overdrive?1.35:1; rg.addColorStop(0,`hsla(${h},80%,70%,${0.12*boost*amp})`); rg.addColorStop(0.4,`hsla(${(h+40)%360},90%,60%,${0.09*boost*amp})`); rg.addColorStop(1,'hsla(0,0%,0%,0)'); ctx.fillStyle=rg; ctx.beginPath(); ctx.arc(0,0,1,0,Math.PI*2); ctx.fill(); ctx.restore(); } ctx.restore();
  const cell=Math.max(28,40*DPR*UIS); ctx.globalAlpha=state.overdrive?0.18:0.12; ctx.beginPath(); const t2=state.time*0.00025*(state.overdrive?1.6:1); for(let x=((t2*60)%cell)-cell;x<W;x+=cell){ ctx.moveTo(x,0); ctx.lineTo(x,H);} for(let y=((t2*40)%cell)-cell;y<H;y+=cell){ ctx.moveTo(0,y); ctx.lineTo(W,y);} ctx.strokeStyle=state.overdrive?'#1b2b50':'#0e1a2c'; ctx.lineWidth=1; ctx.stroke(); ctx.globalAlpha=1;
  ctx.save(); for(const c of state.comets){ ctx.globalCompositeOperation='lighter'; const trail=Math.max(10*DPR,c.len*0.6); const ang=Math.atan2(c.vy,c.vx); ctx.save(); ctx.translate(c.x,c.y); ctx.rotate(ang); const cg=ctx.createLinearGradient(-trail,0,0,0); cg.addColorStop(0,'rgba(124,195,255,0)'); cg.addColorStop(1,state.overdrive?'rgba(180,220,255,0.95)':'rgba(124,195,255,0.9)'); ctx.fillStyle=cg; ctx.beginPath(); ctx.ellipse(-trail/2,0,trail/2,2*DPR,0,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; ctx.beginPath(); ctx.arc(0,0,2.2*DPR,0,Math.PI*2); ctx.fillStyle='#e6f9ff'; ctx.fill(); ctx.restore(); } ctx.restore();
}

// ===== Spawning =====
function pickEnemyType(){ const w=state.wave, pool=[]; const push=(t,n)=>{for(let i=0;i<n;i++) pool.push(t)}; push('grunt',8); if(w>=2) push('weaver', Math.min(5, 1+Math.floor(w/2))); if(w>=3) push('charger',Math.min(3,Math.floor((w-2)/2))); if(w>=4) push('orbiter',Math.min(3,Math.floor((w-3)/2))); if(w>=5) push('shooter',Math.min(2,Math.floor((w-4)/2))); return pool[(Math.random()*pool.length)|0]||'grunt'; }
function spawnEnemy(forceType){
  const m=24*DPR; const edge=(Math.random()*4)|0; let x,y;
  if(edge===0){x=rand(m,W-m);y=-m;} else if(edge===1){x=W+m;y=rand(m,H-m);} else if(edge===2){x=rand(m,W-m);y=H+m;} else {x=-m;y=rand(m,H-m);}
  let type=forceType||pickEnemyType(); if(!forceType && state.wave>=2 && (state.spawned % 3 === 0)) type='weaver';
  const common={x,y,t:0, alive:true, type, color:'#7a4cff'};
  if(type==='grunt') state.enemies.push({...common,r:12*DPR,speed:rand(0.08,0.12)*DPR,color:'#7a4cff'});
  else if(type==='weaver') state.enemies.push({...common,r:11*DPR,speed:rand(0.08,0.11)*DPR,sway:rand(0.003,0.006),phase:rand(0,Math.PI*2),tail:[],color:'#ff7ad1'});
  else if(type==='orbiter') state.enemies.push({...common,r:12*DPR,angle:rand(0,Math.PI*2),radius:rand(70,110)*DPR,color:'#7affd1'});
  else if(type==='charger') state.enemies.push({...common,r:12*DPR,speed:0.09*DPR,phase:'aim',wind:320,vx:0,vy:0,dashSpeed:0.5*DPR,color:'#ff6b6b'});
  else if(type==='shooter') state.enemies.push({...common,r:12*DPR,speed:0.06*DPR,desired:rand(160,220)*DPR,fireCD:rand(700,1000),color:'#6bffb0'});
  state.spawned++;
}

function maybeSpawnWaveChest(){
  if(state.wave % 5 === 0){
    const x = rand(W*0.25, W*0.75), y = rand(H*0.25, H*0.75);
    spawnPowerup('chest', x, y);
    addFloater(x, y-10*DPR, 'WAVE CHEST!');
  }
}

function nextWave(){
  if(!state.tookHitThisWave){
    const bonus = 50 + 10*state.wave;
    state.score += bonus;
    addFloater(W/2, H*0.45, `FLAWLESS +${bonus}`);
    try{ if(navigator.vibrate) navigator.vibrate([10,60,10]); }catch(_){}
  }
  state.tookHitThisWave=false;
  state.wave++; state.waveTarget+=5; state.spawned=0; state.lastSpawn=0;
  state.spawnDelay=Math.max(260,state.spawnDelay*0.9);
  state.shootDelay=Math.max(300,state.shootDelay*0.96);
  dropBanner(`Wave ${state.wave}`);
  if(state.wave>=2){ spawnEnemy('weaver'); }
  state.cometTimer = Math.min(state.cometTimer, 800);
  maybeSpawnWaveChest();
}

// ===== FX & helpers =====
function addFloater(x,y,text){ state.floaters.push({x,y,text,a:1,vy:-0.05*DPR}); }
function addBurst(x,y,n=16,color='#6bbcff'){ for(let i=0;i<n;i++){ const a=Math.random()*Math.PI*2, s=rand(0.6,2.0)*DPR; state.particles.push({x,y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,r:rand(1,3)*DPR,a:1,col:color}); } }
function dropBanner(text){ state.banner.text=text; state.banner.t=1400; }
function killImpact(x,y){ state.hitstop=Math.max(state.hitstop,60); state.ripples.push({x,y,r:10*DPR,max:100*DPR,a:0.9}); }
function spawnPowerup(type,x,y){ state.powerups.push({type,x,y,t:0,r:11*DPR,a:1}); }

// ===== Upgrades Choice (keep from v6 for chests) =====
const UPG_POOL=[
  {id:'speed', label:'+10% Move Speed', apply:()=>{ state.aug.speedMul*=1.10; addFloater(player.x,player.y-16*DPR,'SPEED+'); }},
  {id:'bullet', label:'+15% Bullet Speed', apply:()=>{ state.aug.bulletSpeedMul*=1.15; addFloater(player.x,player.y-16*DPR,'BULLET+'); }},
  {id:'firerate', label:'-12% Shoot Delay', apply:()=>{ state.shootDelay*=0.88; addFloater(player.x,player.y-16*DPR,'RAPID+'); }},
  {id:'size', label:'-10% Player Size', apply:()=>{ state.aug.playerSizeMul*=0.90; player.r = 16*DPR*state.aug.playerSizeMul; addFloater(player.x,player.y-16*DPR,'HITBOX-'); }},
  {id:'combo', label:'+300ms Combo Window', apply:()=>{ state.aug.comboWindowBonus+=300; addFloater(player.x,player.y-16*DPR,'COMBO+'); }},
  {id:'odreq', label:'-5 Combo for Overdrive', apply:()=>{ state.aug.overdriveComboDelta-=5; addFloater(player.x,player.y-16*DPR,'OD THRESH-'); }},
  {id:'oddur', label:'+2s Overdrive', apply:()=>{ state.aug.overdriveMsBonus+=2000; addFloater(player.x,player.y-16*DPR,'OD TIME+'); }},
  {id:'magnet', label:'+50% Magnet Strength', apply:()=>{ state.aug.magnetBoost+=0.5; addFloater(player.x,player.y-16*DPR,'MAGNET+'); }},
];
function pickN(arr,n){ const a=arr.slice(); const out=[]; while(a.length && out.length<n){ out.push(a.splice((Math.random()*a.length)|0,1)[0]); } return out; }
function openChoice(){ state.choice.active=true; state.choice.options = pickN(UPG_POOL, Math.min(3, UPG_POOL.length)); state.choice.picked=null; dropBanner('Choose an Upgrade'); }
function applyUpgrade(opt){ opt.apply(); state.choice.active=false; state.choice.options=[]; state.choice.picked=opt.id; }

// ===== Bounties (mini-quests) =====
function initBounties(){
  state.bounties = [
    {id:'combo10', desc:'Reach Combo x10', done:false, test:()=>state.comboBest>=10, reward:()=>{ state.score+=120; addFloater(W-40*DPR,40*DPR,'BOUNTY +120'); }},
    {id:'graze20', desc:'Graze 20 shots', done:false, count:0, need:20, reward:()=>{ state.bombs=Math.min(9,state.bombs+1); addFloater(W-40*DPR,60*DPR,'BOUNTY BOMB'); }}
  ];
}

// ===== Combat =====
function getNearestEnemy(){ let best=Infinity, pick=null; for(const e of state.enemies){ if(!e.alive) continue; const d=Math.hypot(e.x-player.x,e.y-player.y); if(d<best){best=d; pick=e;} } return pick; }
function shoot(now){
  const haste= state.hasteTimer>0 ? 0.65 : 1;
  const drive= state.overdrive ? 0.55 : 1;
  const fireFactor = Math.min(1, haste*drive);
  if(now-state.lastShot < state.shootDelay*fireFactor) return;
  const e=getNearestEnemy(); if(!e) return;
  const dx=e.x-player.x, dy=e.y-player.y; const base=Math.atan2(dy,dx), speed=8*DPR*(state.aug.bulletSpeedMul||1);
  const level=state.spreadLevel;
  const angles= level===0?[0]:(level===1?[-0.12,0,0.12]:[-0.21,-0.09,0,0.09,0.21]);
  for(const off of angles){
    const a=base+off;
    state.bullets.push({x:player.x,y:player.y, px:player.x,py:player.y, vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, r:3*DPR, life:900});
  }
  state.lastShot=now;
}

function detonateBomb(){
  if(state.bombs<=0||state.gameOver||state.choice.active) return;
  state.bombs--;
  let killed = 0;
  for(const e of state.enemies){
    if(e.alive){
      e.alive = false;
      addBurst(e.x,e.y, (e.type==='charger'||e.type==='shooter'||e.type==='orbiter') ? 28 : 18, e.color||'#6bbcff');
      state.score += 10*state.mult;
      killed++;
    }
  }
  state.enemyShots.length = 0;
  state.shake += Math.min(24*DPR, 8*DPR + killed*0.7*DPR);
  killImpact(player.x,player.y);
  addFloater(player.x,player.y,'BOMB!');
  try{ if(navigator.vibrate) navigator.vibrate([15,35,15]); }catch(_){}
  state.bgPulse = 1.0;
}

// ===== Input =====
canvas.addEventListener('pointerdown',e=>{
  if(state.choice.active){
    const rect=canvas.getBoundingClientRect();
    const px=(e.clientX-rect.left)*DPR, py=(e.clientY-rect.top)*DPR;
    const cardW=Math.min(220*DPR, W*0.26), cardH=90*DPR, gap=16*DPR;
    const totalW=cardW*state.choice.options.length + gap*(state.choice.options.length-1);
    const cx=(W-totalW)/2, cy=H*0.5 - cardH/2;
    for(let i=0;i<state.choice.options.length;i++){
      const x=cx+i*(cardW+gap), y=cy;
      if(px>=x && px<=x+cardW && py>=y && py<=y+cardH){ applyUpgrade(state.choice.options[i]); break; }
    }
    return;
  }
  if(state.gameOver){
    // restart from end screen tap
    boot(); return;
  }
  state.activePointers.add(e.pointerId);
  const rect=canvas.getBoundingClientRect();
  const px=clamp((e.clientX-rect.left)*DPR,0,W);
  const py=clamp((e.clientY-rect.top)*DPR,0,H);
  player.tx=px; player.ty=py;
  if(state.activePointers.size===1){
    state.joy.active=true; state.joy.ox=px; state.joy.oy=py; state.joy.x=px; state.joy.y=py; state.joy.a=1; state.joy.t=0;
  }
  if(state.activePointers.size>=2 && state.bombs>0){ detonateBomb(); return; }
  const now=performance.now();
  const dt=now-state.lastTapTime;
  const near=Math.hypot(px-state.lastTapX,py-state.lastTapY)<20*DPR;
  if(dt<300 && near && state.bombs>0){ detonateBomb(); }
  state.lastTapTime=now; state.lastTapX=px; state.lastTapY=py;
  state.magnet=Math.min(1,(state.magnet||0)+0.25);
  state.justStarted=false; // dismiss start hint
},{passive:true});
canvas.addEventListener('pointermove',e=>{
  if(!state.activePointers.has(e.pointerId) || state.choice.active) return;
  const rect=canvas.getBoundingClientRect();
  const px=clamp((e.clientX-rect.left)*DPR,0,W);
  const py=clamp((e.clientY-rect.top)*DPR,0,H);
  player.tx=px; player.ty=py;
  state.joy.x=px; state.joy.y=py; state.joy.a=Math.min(1, state.joy.a + 0.02);
},{passive:true});
canvas.addEventListener('pointerup',e=>{
  state.activePointers.delete(e.pointerId);
  if(state.activePointers.size===0){ state.joy.active=false; state.magnet=0; }
},{passive:true});
canvas.addEventListener('pointercancel',e=>{
  state.activePointers.delete(e.pointerId);
  if(state.activePointers.size===0){ state.joy.active=false; state.magnet=0; }
},{passive:true});

// ===== Overdrive helpers =====
function enterOverdrive(){
  state.overdrive=true;
  state.overdriveTimer=OVERDRIVE_MS + (state.aug.overdriveMsBonus||0);
  state.overdrivePulse=1;
  state.bgPulse = Math.max(state.bgPulse, 1.0);
  dropBanner('OVERDRIVE!');
  addFloater(player.x, player.y-20*DPR, 'RAPID FIRE!');
  try{ if(navigator.vibrate) navigator.vibrate([12,40,12]); }catch(_){}
}
function exitOverdrive(){ if(state.overdrive){ state.overdrive=false; state.overdriveTimer=0; } }

// ===== Update =====
function update(dt,now){
  const ts=(state.hitstop>0||state.gameOver||state.choice.active)?0.0001:1;
  state.hitstop=Math.max(0,state.hitstop-dt);
  state.time += dt*ts;

  if(state.mult>1){ state.multTimer=Math.max(0,state.multTimer-dt); if(state.multTimer<=0){ state.mult=1; }}
  state.displayScore += (state.score-state.displayScore)*0.18;
  state.invuln=Math.max(0,state.invuln-dt);
  state.hasteTimer=Math.max(0,state.hasteTimer-dt);
  state.magnetBoostTimer=Math.max(0,state.magnetBoostTimer-dt);
  state.joy.t += dt; state.joy.a = state.joy.active ? Math.min(1, state.joy.a + dt*0.004) : Math.max(0, state.joy.a - dt*0.0035);
  state.bgPulse = Math.max(0, state.bgPulse - dt*0.0012);
  state.comboPulse = Math.max(0, state.comboPulse - dt*0.004);
  state.overdrivePulse = Math.max(0, state.overdrivePulse - dt*0.003);

  const comboWindow = COMBO_WINDOW + (state.aug.comboWindowBonus||0);
  if(state.combo>0){
    state.comboTimeMs=Math.max(0,state.comboTimeMs-dt);
    if(state.comboTimeMs===0){ state.combo=0; exitOverdrive(); }
  }
  if(state.overdrive){
    state.overdriveTimer = Math.max(0, state.overdriveTimer - dt);
    if(state.overdriveTimer===0) exitOverdrive();
  }

  for(const gal of state.galaxies){ gal.rot += gal.rotSpeed*dt; }
  const ox=(player.x-W/2)*0.00025, oy=(player.y-H/2)*0.00025;
  for(const s of state.stars){ s.x+=ox*(s.z===1?14:7); s.y+=oy*(s.z===1?14:7); if(s.x<0)s.x+=W; if(s.x>W)s.x-=W; if(s.y<0)s.y+=H; if(s.y>H)s.y-=H; s.tw+=dt*0.01; }
  for(let i=0;i<state.nebula.length;i++){ const n=state.nebula[i]; n.x += Math.sin((state.time*0.0001)+i)*0.1*DPR; n.y += Math.cos((state.time*0.00008)+i)*0.08*DPR; }

  state.cometTimer -= dt; if(state.cometTimer<=0){
    const edge = (Math.random()*4)|0; let x,y,vx,vy; const speed = rand(0.25,0.45)*DPR; const angJitter = rand(-0.25,0.25);
    if(edge===0){ x=-20*DPR; y=rand(0,H); const ang = 0+angJitter; vx=Math.cos(ang)*speed; vy=Math.sin(ang)*speed; }
    else if(edge===1){ x=W+20*DPR; y=rand(0,H); const ang = Math.PI+angJitter; vx=Math.cos(ang)*speed; vy=Math.sin(ang)*speed; }
    else if(edge===2){ x=rand(0,W); y=-20*DPR; const ang = Math.PI/2+angJitter; vx=Math.cos(ang)*speed; vy=Math.sin(ang)*speed; }
    else { x=rand(0,W); y=H+20*DPR; const ang = -Math.PI/2+angJitter; vx=Math.cos(ang)*speed; vy=Math.sin(ang)*speed; }
    state.comets.push({x,y,vx,vy,life:rand(900,1400),len:rand(50,110)});
    const base = rand(12000, 22000); const bonus = Math.max(0, 5000 - state.wave*400); state.cometTimer = Math.max(6000, base - bonus);
  }
  for(const c of state.comets){ c.x+=c.vx*dt; c.y+=c.vy*dt; c.life-=dt; }
  state.comets = state.comets.filter(c=> c.life>0 && c.x>-50 && c.x<W+50 && c.y>-50 && c.y<H+50);

  // player movement & trail
  const moveSpeed = player.speed * (state.aug.speedMul||1);
  state.trails.push({x:player.x,y:player.y,r:player.r,a:0.5}); state.trails=state.trails.filter(t=>(t.a-=0.02)>0);
  const dxp=player.tx-player.x, dyp=player.ty-player.y, lp=Math.hypot(dxp,dyp); if(lp>0.1){ const step=Math.min(lp,moveSpeed*dt*ts); player.x+=(dxp/lp)*step; player.y+=(dyp/lp)*step; }

  // spawns
  state.lastSpawn+=dt*ts; if(state.spawned<state.waveTarget && state.lastSpawn>state.spawnDelay){ spawnEnemy(); state.lastSpawn=0; }

  // enemies
  for(const e of state.enemies){ if(!e.alive) continue; e.px=e.x; e.py=e.y; e.t+=dt*ts;
    if(e.type==='grunt'){
      const dx=player.x-e.x, dy=player.y-e.y, l=Math.hypot(dx,dy)||1; e.x+=(dx/l)*e.speed*dt*ts; e.y+=(dy/l)*e.speed*dt*ts;
    } else if(e.type==='weaver'){
      const dx=player.x-e.x, dy=player.y-e.y, l=Math.hypot(dx,dy)||1; const nx=dx/l, ny=dy/l; const sx=-ny, sy=nx; const wiggle=Math.sin(e.t*e.sway+e.phase)*0.8; e.x+=(nx*e.speed+sx*e.speed*wiggle)*dt*ts; e.y+=(ny*e.speed+sy*e.speed*wiggle)*dt*ts; e.tail=e.tail||[]; const last=e.tail[e.tail.length-1]; if(!last || Math.hypot(e.x-last.x,e.y-last.y)>2.5*DPR){ e.tail.push({x:e.x,y:e.y}); if(e.tail.length>40) e.tail.shift(); }
    } else if(e.type==='orbiter'){
      e.angle=(e.angle||0)+0.0028*dt*ts; e.x=player.x+Math.cos(e.angle)*e.radius; e.y=player.y+Math.sin(e.angle)*e.radius;
    } else if(e.type==='charger'){
      if(e.phase==='aim'){
        const dx=player.x-e.x,dy=player.y-e.y,l=Math.hypot(dx,dy)||1; e.x+=(dx/l)*e.speed*dt*ts; e.y+=(dy/l)*e.speed*dt*ts; e.wind-=dt*ts;
        if(e.wind<=0){ const dx2=player.x-e.x,dy2=player.y-e.y,L=Math.hypot(dx2,dy2)||1; e.vx=(dx2/L)*e.dashSpeed; e.vy=(dy2/L)*e.dashSpeed; e.phase='dash'; e.dashT=260; }
      } else { e.x+=e.vx*dt*ts; e.y+=e.vy*dt*ts; e.dashT-=dt*ts; if(e.dashT<=0){ e.phase='aim'; e.wind=380; } }
    } else if(e.type==='shooter'){
      const dx=player.x-e.x,dy=player.y-e.y,l=Math.hypot(dx,dy)||1; const nx=dx/l,ny=dy/l; let mx=0,my=0; const ideal=e.desired; const d=l;
      if(d<ideal*0.9){ mx-=nx*e.speed*dt*ts; my-=ny*e.speed*dt*ts; }
      else if(d>ideal*1.1){ mx+=nx*e.speed*dt*ts; my+=ny*e.speed*dt*ts; }
      else { mx+=-ny*e.speed*0.6*dt*ts; my+=nx*e.speed*0.6*dt*ts; }
      e.x+=mx; e.y+=my; e.fireCD-=dt*ts; if(e.fireCD<=0){ const sx=(dx/l)*2.6*DPR, sy=(dy/l)*2.6*DPR; state.enemyShots.push({x:e.x,y:e.y,vx:sx,vy:sy,r:3*DPR,life:1800}); e.fireCD=rand(700,1100); }
    }
    if(Math.hypot(e.x-player.x,e.y-player.y) < (e.r+player.r)){
      if(state.invuln<=0){
        e.alive=false; addBurst(player.x,player.y,20,e.color||'#6bbcff'); state.shake=8*DPR;
        state.mult=1; state.multTimer=0; state.geomCapReached=false; state.scorePulse=1;
        state.enemyShots.length=0; state.enemies.length=0;
        state.lives--; state.tookHitThisWave=true; state.combo=0; state.comboTimeMs=0;
        exitOverdrive();
        if(state.lives>0){ player.x=W/2; player.y=H/2; player.tx=player.x; player.ty=player.y; state.invuln=2500; addFloater(player.x,player.y,'-1 LIFE'); }
        else { state.gameOver=true; handleRunEnd(); dropBanner('GAME OVER'); }
      }
    }
  }
  state.enemies = state.enemies.filter(e=>e.alive);

  // bullets vs enemies
  for(const b of state.bullets){ b.px=b.x; b.py=b.y; b.x+=b.vx*ts; b.y+=b.vy*ts; b.life-=dt*ts; }
  for(const b of state.bullets){
    if(b.life<=0) continue;
    for(const e of state.enemies){
      if(!e.alive) continue;
      const R = e.r + b.r + 1.5*DPR;
      const hit = (
        segHitsCircle(b.px,b.py,b.x,b.y, e.x,e.y, R) ||
        segHitsCircle(b.px,b.py,b.x,b.y, (e.px||e.x), (e.py||e.y), R) ||
        segHitsCircle(b.px,b.py,b.x,b.y, ((e.x+(e.px||e.x))*0.5), ((e.y+(e.py||e.y))*0.5), R)
      );
      if(hit){
        e.alive=false; b.life=0; state.score+=10*state.mult; state.scorePulse=1;
        const isBig=(e.type==='charger'||e.type==='shooter'||e.type==='orbiter');
        addBurst(e.x,e.y,isBig?28:16, e.color||'#6bbcff'); addFloater(e.x,e.y,'+'+(10*state.mult));
        state.shake+=isBig?6*DPR:3*DPR;

        const prevCombo = state.combo;
        state.combo = (state.combo||0) + 1;
        state.comboBest = Math.max(state.comboBest||0, state.combo);
        state.comboTimeMs = comboWindow;
        if(state.combo % 5 === 0){ addFloater(e.x, e.y, `COMBO x${state.combo}`); try{ if(navigator.vibrate) navigator.vibrate(10); }catch(_){} state.shake += 2*DPR; }
        if(Math.floor(prevCombo/10) !== Math.floor(state.combo/10)){ state.comboMilestone++; state.comboPulse = 1; state.bgPulse = Math.max(state.bgPulse, 0.8); }
        state.score += Math.floor(state.combo * 0.3);

        const odNeed = Math.max(1, OVERDRIVE_COMBO + (state.aug.overdriveComboDelta||0));
        if(!state.overdrive && state.combo >= odNeed){ enterOverdrive(); state.hasteTimer = Math.max(state.hasteTimer, (OVERDRIVE_MS + (state.aug.overdriveMsBonus||0))); }

        const roll=Math.random(); const allowGeom=!state.geomCapReached && state.mult<state.multCap; const geomCount=state.powerups.filter(p=>p.type==='geom').length;
        if(allowGeom && geomCount<3 && roll<0.28){ spawnPowerup('geom',e.x,e.y);}
        else if(isBig){
          if(roll < 0.06){ spawnPowerup('bomb',e.x,e.y);}
          else if(roll < 0.12){ spawnPowerup('shield',e.x,e.y);}
          else if(roll < 0.18){ spawnPowerup('spread',e.x,e.y);}
          else if(roll < 0.24){ spawnPowerup('haste',e.x,e.y);}
          else if(roll < 0.30){ spawnPowerup('hp',e.x,e.y); }
          else if(roll < 0.36){ spawnPowerup('magnetP',e.x,e.y); }
        } else {
          if(roll < 0.03){ spawnPowerup('spread',e.x,e.y);}
          else if(roll < 0.045){ spawnPowerup('hp',e.x,e.y);}
          else if(roll < 0.06){ spawnPowerup('magnetP',e.x,e.y);}
        }
        if(isBig) killImpact(e.x,e.y);
        break;
      }
    }
  }
  state.bullets = state.bullets.filter(b=>b.life>0);

  // enemy shots
  for(const s of state.enemyShots){ s.x+=s.vx*ts; s.y+=s.vy*ts; s.life-=dt*ts; }

  // graze
  for(const s of state.enemyShots){
    const d = Math.hypot(s.x - player.x, s.y - player.y);
    const inner = player.r + (s.r||0) + 1;
    const outer = player.r + 10*DPR;
    if(!s._grazed && d > inner && d < outer){
      addFloater(player.x, player.y, '+1 GRAZE');
      state.score += 1;
      if(state.combo===0) state.combo = 1;
      state.comboTimeMs = Math.max(state.comboTimeMs||0, 900);
      state.particles.push({x:player.x, y:player.y, vx:0, vy:0, r:1.5*DPR, a:0.8, col:'#aeefff'});
      s._grazed = true;
      const b=state.bounties.find(x=>x.id==='graze20'); if(b && !b.done){ b.count=(b.count||0)+1; if(b.count>=b.need){ b.done=true; b.reward(); }}
    }
  }

  for(const s of state.enemyShots){
    if(Math.hypot(s.x-player.x,s.y-player.y)<s.r+player.r){
      if(state.invuln<=0){
        s.life=0; state.lives--; state.tookHitThisWave=true; state.combo=0; state.comboTimeMs=0;
        addBurst(player.x,player.y,18,'#ffb3b3'); state.shake=8*DPR; state.mult=1; state.multTimer=0; state.geomCapReached=false; state.scorePulse=1;
        state.enemyShots.length=0; state.enemies.length=0;
        exitOverdrive();
        if(state.lives>0){ player.x=W/2; player.y=H/2; player.tx=player.x; player.ty=player.y; state.invuln=2500; addFloater(player.x,player.y,'-1 LIFE'); }
        else { state.gameOver=true; handleRunEnd(); dropBanner('GAME OVER'); }
      } else { s.life=0; }
    }
  }
  state.enemyShots = state.enemyShots.filter(s=>s.life>0);

  // powerups drift
  for(const p of state.powerups){ p.t+=dt*ts; p.y += Math.sin(p.t*0.003)*0.1*DPR; }
  if(state.powerups.length){
    const basePull = 0.035*DPR * (1 + (state.aug.magnetBoost||0));
    const boost = state.magnetBoostTimer>0 ? 1.8 : 1;
    const pull = basePull * (1 + (state.magnet||0)*3) * boost;
    for(const p of state.powerups){
      const dx = player.x - p.x, dy = player.y - p.y;
      const d  = Math.hypot(dx, dy) || 1;
      if(d < 260*DPR){
        p.x += (dx/d) * pull * dt;
        p.y += (dy/d) * pull * dt;
      }
    }
  }

  // pickups
  for(const p of state.powerups){
    if(Math.hypot(p.x-player.x,p.y-player.y)<player.r+p.r){
      let bonusScore = 4; // base pickup points
      if(p.type==='geom'){ state.mult=Math.min(state.multCap,state.mult+1); if(state.mult>=state.multCap){ state.geomCapReached=true; bonusScore+=6; } state.multTimer=6000; addFloater(p.x,p.y,'x'+state.mult); state.scorePulse=1; }
      else if(p.type==='bomb'){ const before=state.bombs; state.bombs=Math.min(9,state.bombs+1); bonusScore += (state.bombs===before?6:0); addFloater(p.x,p.y,'BOMB+'); }
      else if(p.type==='shield'){ const before=state.invuln; state.invuln=Math.max(state.invuln,2500); bonusScore += (before>0?6:0); addFloater(p.x,p.y,'SHIELD'); }
      else if(p.type==='spread'){ const before=state.spreadLevel; state.spreadLevel=Math.min(2,state.spreadLevel+1); bonusScore += (state.spreadLevel===before?6:0); addFloater(p.x,p.y,'SPREAD'); }
      else if(p.type==='haste'){ const before=state.hasteTimer; state.hasteTimer=Math.max(state.hasteTimer,6000); bonusScore += (before>0?6:0); addFloater(p.x,p.y,'HASTE'); }
      else if(p.type==='hp'){ const before=state.lives; state.lives=Math.min(5,state.lives+1); bonusScore += (state.lives===before?8:0); addFloater(p.x,p.y,'LIFE+'); }
      else if(p.type==='magnetP'){ const before=state.magnetBoostTimer; state.magnetBoostTimer=Math.max(state.magnetBoostTimer,7000); bonusScore += (before>0?6:0); addFloater(p.x,p.y,'MAGNET+'); }
      else if(p.type==='chest'){ openChoice(); bonusScore = 0; }
      if(bonusScore>0){ state.score += bonusScore; addFloater(p.x, p.y-10*DPR, '+'+bonusScore); }
      p.a=0;
    }
  }
  state.powerups=state.powerups.filter(p=>p.a!==0);

  // fx lifetimes
  for(const r of state.ripples){ r.r+=0.5*DPR*dt/16; r.a-=0.0025*dt; } state.ripples=state.ripples.filter(r=>r.a>0);
  for(const p of state.particles){ p.x+=p.vx*ts; p.y+=p.vy*ts; p.a-=0.02*ts; p.vx*=0.99; p.vy*=0.99; } state.particles=state.particles.filter(p=>p.a>0);
  for(const f of state.floaters){ f.y+=f.vy*ts; f.a-=0.01*ts; } state.floaters=state.floaters.filter(f=>f.a>0);

  shoot(now); state.shake*=0.92;
  if(state.spawned>=state.waveTarget && state.enemies.length===0){ nextWave(); }
}

// ===== UI helpers =====
function drawIconBomb(x,y,size){ const r=size/2; ctx.save(); ctx.translate(x,y); ctx.rotate(0.2*Math.sin(state.time*0.01)); ctx.beginPath(); ctx.moveTo(0,-r); ctx.lineTo(r,0); ctx.lineTo(0,r); ctx.lineTo(-r,0); ctx.closePath(); ctx.fillStyle='#ffae6b'; ctx.fill(); ctx.restore(); }
function drawIconSpread(x,y,size){ ctx.save(); ctx.translate(x,y); drawStar(0,0,5,size*0.55,size*0.26, state.time*0.004); ctx.fillStyle='#ffd2ff'; ctx.fill(); ctx.restore(); }
function drawIconHaste(x,y,size){ ctx.save(); ctx.translate(x,y); ctx.rotate(0.2); ctx.beginPath(); ctx.moveTo(-0.25*size, -0.35*size); ctx.lineTo(0.2*size, -0.05*size); ctx.lineTo(-0.05*size, -0.05*size); ctx.lineTo(0.25*size, 0.45*size); ctx.lineTo(-0.25*size, 0.05*size); ctx.lineTo(0, 0.05*size); ctx.closePath(); ctx.fillStyle='#7cc3ff'; ctx.fill(); ctx.restore(); }
function drawIconShield(x,y,size){ ctx.save(); ctx.beginPath(); ctx.arc(x,y,size*0.5,0,Math.PI*2); ctx.strokeStyle='#6bffea'; ctx.lineWidth=2*DPR; ctx.stroke(); ctx.restore(); }
function drawHUD(){
  // lives (hearts)
  const lifeX=W-16*DPR, lifeY=18*UIS*DPR;
  ctx.save(); ctx.textAlign='right';
  for(let i=0;i<state.lives;i++){ ctx.beginPath(); ctx.arc(lifeX-i*18*DPR, lifeY, 6*DPR, 0, Math.PI*2); ctx.fillStyle='#ff6b6b'; ctx.fill(); }
  ctx.restore();

  // status icons row (left-bottom)
  const baseY = H-14*UIS*DPR;
  const s = 12*DPR;
  let x = 10*DPR;

  // bombs
  drawIconBomb(x, baseY-2*DPR, s); x += 16*DPR;
  ctx.font=`${12*UIS*DPR}px system-ui`; ctx.fillStyle='rgba(230,240,255,0.9)'; ctx.textAlign='left';
  ctx.fillText('×'+state.bombs, x, baseY); x += 34*DPR;

  // spread
  drawIconSpread(x, baseY-2*DPR, s); x += 16*DPR;
  ctx.fillText('×'+state.spreadLevel, x, baseY); x += 34*DPR;

  // haste
  drawIconHaste(x, baseY-1*DPR, s); x += 16*DPR;
  ctx.fillText(state.hasteTimer>0? Math.ceil(state.hasteTimer/1000)+'s':'×0', x, baseY); x += 40*DPR;

  // shield
  drawIconShield(x, baseY-2*DPR, s); x += 16*DPR;
  ctx.fillText(state.invuln>0? Math.ceil(state.invuln/1000)+'s':'×0', x, baseY);
}

function drawComboMeter(){
  const maxW = Math.min(W*0.6, 360*DPR);
  const barH = 8*DPR;
  const x = (W - maxW)/2;
  const y = Math.max(14*UIS*DPR, 10*DPR) + (26*UIS*DPR) + 4*DPR + (14*DPR);
  const t = clamp(state.comboTimeMs/(COMBO_WINDOW + (state.aug.comboWindowBonus||0)), 0, 1);
  const milestoneEvery = 10;
  ctx.save();
  ctx.globalAlpha = 0.7;
  ctx.fillStyle = 'rgba(15,25,45,0.9)';
  ctx.roundRect ? ctx.roundRect(x, y, maxW, barH, 4*DPR) : ctx.fillRect(x, y, maxW, barH);
  ctx.fill();
  const fillW = maxW * t;
  const hue = state.overdrive ? 190 : 200 + 20*Math.sin(state.time*0.01);
  const grad = ctx.createLinearGradient(x, y, x+fillW, y);
  grad.addColorStop(0, `hsla(${hue},100%,70%,0.95)`);
  grad.addColorStop(1, `hsla(${hue+60},100%,70%,0.95)`);
  ctx.globalAlpha = 0.95;
  ctx.fillStyle = grad;
  ctx.roundRect ? ctx.roundRect(x, y, fillW, barH, 4*DPR) : ctx.fillRect(x, y, fillW, barH);
  ctx.fill();
  ctx.globalAlpha = 0.55;
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 1*DPR;
  const ticks = Math.max(0, Math.floor(state.combo / milestoneEvery));
  for(let i=1;i<=Math.max(1, ticks+3);i++){
    const tx = x + (i*milestoneEvery/Math.max(OVERDRIVE_COMBO, milestoneEvery)) * maxW;
    ctx.beginPath(); ctx.moveTo(tx, y); ctx.lineTo(tx, y+barH); ctx.stroke();
  }
  if(state.comboPulse>0){
    ctx.globalAlpha = 0.25 * state.comboPulse;
    ctx.strokeStyle = 'rgba(255,220,120,0.9)';
    ctx.lineWidth = 4*DPR * state.comboPulse;
    ctx.strokeRect(x-2*DPR, y-2*DPR, maxW+4*DPR, barH+4*DPR);
  }
  ctx.restore();
}

function drawBounties(){
  if(!state.bounties || !state.bounties.length) return;
  const baseX = 10*DPR, baseY = 14*DPR;
  ctx.save();
  ctx.textAlign='left';
  ctx.font=`${11*UIS*DPR}px system-ui`;
  for(let i=0;i<state.bounties.length;i++){
    const b=state.bounties[i];
    const y = baseY + i*14*DPR;
    ctx.fillStyle = b.done ? '#9bffb0' : 'rgba(230,240,255,0.8)';
    let label = '• ' + b.desc;
    if(b.need) label += ` (${Math.min(b.count||0,b.need)}/${b.need})`;
    ctx.fillText(label, baseX, y);
  }
  ctx.restore();
}

function drawChoiceOverlay(){
  if(!state.choice.active) return;
  ctx.save();
  ctx.globalAlpha=0.85;
  ctx.fillStyle='#05060b';
  ctx.fillRect(0,0,W,H);
  ctx.globalAlpha=1;
  ctx.font=`${18*UIS*DPR}px system-ui`; ctx.textAlign='center'; ctx.fillStyle='#e6f0ff';
  ctx.fillText('Choose One Upgrade', W/2, H*0.35);
  const cardW=Math.min(220*DPR, W*0.26), cardH=90*DPR, gap=16*DPR;
  const totalW=cardW*state.choice.options.length + gap*(state.choice.options.length-1);
  const cx=(W-totalW)/2, cy=H*0.5 - cardH/2;
  for(let i=0;i<state.choice.options.length;i++){
    const opt=state.choice.options[i];
    const x=cx+i*(cardW+gap), y=cy;
    ctx.fillStyle='rgba(18,28,50,0.95)';
    ctx.roundRect ? ctx.roundRect(x,y,cardW,cardH,8*DPR) : ctx.fillRect(x,y,cardW,cardH);
    ctx.fill();
    ctx.strokeStyle='rgba(140,180,255,0.6)'; ctx.lineWidth=2*DPR; ctx.strokeRect(x+1*DPR,y+1*DPR,cardW-2*DPR,cardH-2*DPR);
    ctx.font=`${13*UIS*DPR}px system-ui`; ctx.textAlign='center'; ctx.fillStyle='#cfe5ff';
    ctx.fillText(opt.label, x+cardW/2, y+cardH/2);
  }
  ctx.font=`${10*UIS*DPR}px system-ui`; ctx.fillStyle='rgba(230,240,255,0.7)';
  ctx.fillText('Tap to pick • Pauses game', W/2, cy+cardH+16*DPR);
  ctx.restore();
}

// ===== Draw =====
function draw(){
  ctx.clearRect(0,0,W,H); drawBackground(); ctx.save(); if(state.shake>0){ ctx.translate((Math.random()*2-1)*state.shake, (Math.random()*2-1)*state.shake); }
  // trails
  ctx.globalCompositeOperation='lighter'; for(const t of state.trails){ ctx.globalAlpha=t.a; ctx.beginPath(); ctx.arc(t.x,t.y,t.r,0,Math.PI*2); ctx.fillStyle= state.overdrive ? '#66ffe0' : player.color; ctx.fill(); } ctx.globalAlpha=1; ctx.globalCompositeOperation='source-over';
  // ripples + particles
  for(const r of state.ripples){ ctx.beginPath(); ctx.arc(r.x,r.y,r.r,0,Math.PI*2); ctx.strokeStyle=`rgba(255,255,255,${Math.max(0,r.a)})`; ctx.lineWidth=2*DPR; ctx.stroke(); }
  ctx.globalCompositeOperation='lighter'; for(const p of state.particles){ ctx.globalAlpha=p.a; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fillStyle=p.col|| (state.overdrive ? '#aeefff' : '#6bbcff'); ctx.fill(); } ctx.globalAlpha=1; ctx.globalCompositeOperation='source-over';

  // enemy weaver trails
  for(const e of state.enemies){ if(e.type==='weaver' && e.tail){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.shadowColor=e.color; ctx.shadowBlur=10*DPR; for(let i=0;i<e.tail.length;i++){ const t=e.tail[i]; const a=i/(e.tail.length-1||1); const rSeg=(e.r*0.35)+(e.r*0.95)*a; ctx.globalAlpha=0.06+0.6*a; ctx.beginPath(); ctx.arc(t.x,t.y,rSeg,0,Math.PI*2); ctx.fillStyle=e.color; ctx.fill(); } ctx.restore(); } }

  // enemies
  for(const e of state.enemies){ ctx.save(); ctx.shadowColor=e.color; ctx.shadowBlur=12*DPR; ctx.fillStyle=e.color; ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0; ctx.strokeStyle='rgba(255,255,255,0.12)'; ctx.lineWidth=2*DPR; ctx.stroke(); ctx.restore(); }

  // enemy shots
  ctx.globalCompositeOperation='lighter'; for(const s of state.enemyShots){ ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fillStyle= state.overdrive ? '#ffc7c7' : '#ff9b9b'; ctx.fill(); } ctx.globalCompositeOperation='source-over';

  // powerups
  for(const p of state.powerups){
    const pulse=(Math.sin(p.t*0.01)+1)*0.5; ctx.save();
    if(p.type==='geom'){ ctx.globalCompositeOperation='lighter'; ctx.translate(p.x,p.y); ctx.rotate(p.t*0.004); const r=p.r*(0.9+0.2*pulse); ctx.beginPath(); for(let i=0;i<6;i++){ const a=-Math.PI/2 + i*Math.PI/3; const xx=Math.cos(a)*r, yy=Math.sin(a)*r; i?ctx.lineTo(xx,yy):ctx.moveTo(xx,yy);} ctx.closePath(); ctx.strokeStyle='#ffd866'; ctx.lineWidth=3*DPR; ctx.stroke(); ctx.globalCompositeOperation='source-over'; }
    else if(p.type==='bomb'){ ctx.translate(p.x,p.y); ctx.rotate(p.t*0.005); ctx.beginPath(); ctx.moveTo(0,-p.r); ctx.lineTo(p.r,0); ctx.lineTo(0,p.r); ctx.lineTo(-p.r,0); ctx.closePath(); ctx.fillStyle='#ffae6b'; ctx.fill(); }
    else if(p.type==='shield'){ ctx.beginPath(); ctx.arc(p.x,p.y,p.r*(0.9+0.2*pulse),0,Math.PI*2); ctx.strokeStyle='#6bffea'; ctx.lineWidth=3*DPR; ctx.stroke(); }
    else if(p.type==='spread'){ ctx.globalCompositeOperation='lighter'; drawStar(p.x,p.y,5,p.r*1.1,p.r*0.5,p.t*0.004); ctx.fillStyle='#ffd2ff'; ctx.shadowColor='#ff8cff'; ctx.shadowBlur=12*DPR; ctx.fill(); ctx.shadowBlur=0; ctx.globalCompositeOperation='source-over'; }
    else if(p.type==='haste'){ ctx.globalCompositeOperation='lighter'; ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.t*0.006); ctx.beginPath(); ctx.moveTo(-0.2*p.r, -0.5*p.r); ctx.lineTo(0.18*p.r, -0.1*p.r); ctx.lineTo(-0.05*p.r, -0.1*p.r); ctx.lineTo(0.25*p.r, 0.5*p.r); ctx.lineTo(-0.25*p.r, 0.1*p.r); ctx.lineTo(0, 0.1*p.r); ctx.closePath(); ctx.fillStyle='#7cc3ff'; ctx.shadowColor='#7cc3ff'; ctx.shadowBlur=12*DPR; ctx.fill(); ctx.restore(); ctx.globalCompositeOperation='source-over'; }
    else if(p.type==='hp'){ // heart
      ctx.translate(p.x,p.y);
      const r=p.r*(1.0+0.15*pulse);
      ctx.beginPath();
      ctx.moveTo(0, r*0.4);
      ctx.bezierCurveTo(r*0.8, r*0.1, r*0.8, -r*0.6, 0, -r*0.2);
      ctx.bezierCurveTo(-r*0.8, -r*0.6, -r*0.8, r*0.1, 0, r*0.4);
      ctx.fillStyle='#ff6b6b'; ctx.fill();
    }
    else if(p.type==='magnetP'){
      ctx.translate(p.x,p.y);
      const r=p.r*(1.0+0.1*pulse);
      ctx.beginPath();
      ctx.arc(0,0,r,Math.PI*0.15,Math.PI*1.85,false);
      ctx.lineWidth=4*DPR; ctx.strokeStyle='#ffd866'; ctx.stroke();
      ctx.beginPath(); ctx.arc(r*0.6,0, r*0.18, 0, Math.PI*2); ctx.fillStyle='#ffd866'; ctx.fill();
      ctx.beginPath(); ctx.arc(-r*0.6,0, r*0.18, 0, Math.PI*2); ctx.fillStyle='#ffd866'; ctx.fill();
    }
    else if(p.type==='chest'){
      ctx.translate(p.x,p.y); ctx.rotate(0.02*Math.sin(p.t*0.01));
      const r=p.r*(1.0+0.1*pulse); ctx.fillStyle='#ffd866'; ctx.fillRect(-r*0.9,-r*0.7, r*1.8, r*1.4);
      ctx.fillStyle='#ff8c66'; ctx.fillRect(-r*0.18,-r*0.7, r*0.36, r*1.4);
      ctx.fillStyle='#ffe9a6'; ctx.fillRect(-r*0.9,-r*0.1, r*1.8, r*0.2);
      ctx.beginPath(); ctx.arc(-r*0.25,-r*0.7, r*0.25, 0, Math.PI*2); ctx.arc(r*0.25,-r*0.7, r*0.25, 0, Math.PI*2); ctx.fillStyle='#ffb899'; ctx.fill();
    }
    ctx.restore();
  }

  // bullets
  ctx.globalCompositeOperation='lighter';
  for(const b of state.bullets){
    ctx.beginPath(); ctx.moveTo(b.px,b.py); ctx.lineTo(b.x,b.y);
    ctx.strokeStyle= state.overdrive ? '#baf4ff' : '#9be0ff';
    ctx.lineWidth=2*DPR; ctx.stroke();
    ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
    ctx.fillStyle= state.overdrive ? '#eaffff' : '#e6f9ff'; ctx.fill();
  }
  ctx.globalCompositeOperation='source-over';

  // player + spawn protection shimmer
  ctx.save();
  const playerCol= state.overdrive ? '#66ffe0' : player.color;
  ctx.shadowColor=playerCol; ctx.shadowBlur= state.overdrive ? 20*DPR : 14*DPR; ctx.fillStyle=playerCol;
  ctx.beginPath(); ctx.arc(player.x,player.y,player.r,0,Math.PI*2); ctx.fill();
  ctx.shadowBlur=0; ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.lineWidth=2*DPR; ctx.stroke();
  if(state.invuln>0){
    // thicker shimmering ring
    const t = state.time*0.02;
    ctx.beginPath(); ctx.arc(player.x,player.y,player.r+6*DPR + 1.5*DPR*Math.sin(t*3),0,Math.PI*2);
    ctx.strokeStyle='rgba(107,255,234,0.9)'; ctx.lineWidth=2.5*DPR; ctx.setLineDash([6*DPR, 6*DPR]); ctx.lineDashOffset = -t*10; ctx.stroke(); ctx.setLineDash([]);
  }
  ctx.restore();

  // score + combo text
  const scoreColor = state.mult>=3 ? '#ffd866' : (state.mult===2 ? '#b0ff9b' : '#e6f0ff');
  const baseFont = 26*UIS*DPR;
  const multBoost = Math.max(0, state.mult-1);
  const pulseScale = 1 + 0.12*state.scorePulse + 0.05*state.overdrivePulse;
  const multScale = 1 + 0.22*multBoost;
  const shakeAmp = (0.25 + 0.12*state.scorePulse) * multBoost * DPR;
  const t = state.time*0.02;
  const dx = Math.sin(t*7) * shakeAmp;
  const dy = Math.cos(t*9) * shakeAmp*0.4;

  ctx.save();
  const yTop = Math.max(14*UIS*DPR, 10*DPR) + dy;
  ctx.translate(W/2 + dx, yTop);
  ctx.scale(pulseScale*multScale, pulseScale*multScale);
  ctx.font = `${baseFont}px system-ui`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.fillStyle = scoreColor;
  ctx.shadowColor = scoreColor;
  ctx.shadowBlur = (12 + 12*multBoost) * DPR;
  ctx.fillText(Math.round(state.displayScore).toLocaleString(), 0, 0);

  // combo line
  ctx.font=`${12*UIS*DPR}px system-ui`;
  ctx.fillStyle='rgba(230,240,255,0.85)';
  const comboLine = state.combo>0 ? `Combo x${state.combo}${state.overdrive?'  • OVERDRIVE':''}` : `Best x${state.comboBest||0}`;
  ctx.fillText(comboLine, 0, (26*UIS*DPR) + 4*DPR);
  ctx.restore();

  // combo meter bar
  drawComboMeter();

  // HUD icons row
  drawHUD();

  // bounties
  drawBounties();

  // start hint
  if(state.justStarted){
    ctx.font=`${14*UIS*DPR}px system-ui`; ctx.fillStyle='rgba(230,240,255,0.8)'; ctx.textAlign='center';
    ctx.fillText('Drag to move • Two-finger = BOMB', W/2, H*0.65);
  }

  // banner / end-of-run overlay
  if(state.banner.t>0){ state.banner.t-=16; const a=Math.max(0,Math.min(1,state.banner.t/1400)); ctx.globalAlpha=a; ctx.font=`${28*UIS*DPR}px system-ui`; ctx.textAlign='center'; ctx.fillText(state.banner.text, W/2, H/2); ctx.globalAlpha=1; }

  if(state.gameOver){
    drawEndScreen();
  }

  // floaters
  ctx.fillStyle='#fff'; ctx.textAlign='center';
  for(const f of state.floaters){ const fs=(12*UIS*DPR + (1-f.a)*8*DPR); ctx.font=`${fs}px system-ui`; ctx.globalAlpha=f.a; ctx.fillText(f.text,f.x,f.y); } ctx.globalAlpha=1;

  // choice overlay + joystick
  drawChoiceOverlay();
  drawJoystick();
  ctx.restore();

  // version tag
  ctx.font=`${10*UIS*DPR}px system-ui`; ctx.fillStyle='rgba(200,220,255,0.7)'; ctx.textAlign='right'; ctx.fillText('v7', W-8*DPR, H-8*DPR);
}

function drawJoystick(){ const j=state.joy; if(!j || j.a<=0) return; const baseR=26*UIS*DPR; const knobR=10*UIS*DPR; const dx=j.x-j.ox, dy=j.y-j.oy; const len=Math.hypot(dx,dy); const cap=48*UIS*DPR; const nx=len>0?dx/len:0, ny=len>0?dy/len:0; const kx=j.ox + nx*Math.min(len,cap); const ky=j.oy + ny*Math.min(len,cap);
  ctx.save(); ctx.globalAlpha=0.35*j.a; ctx.beginPath(); ctx.arc(j.ox,j.oy,baseR,0,Math.PI*2); ctx.fillStyle='#0e1a2c'; ctx.fill(); ctx.lineWidth=2*DPR; ctx.strokeStyle='rgba(124,195,255,0.6)'; ctx.stroke();
  ctx.beginPath(); ctx.moveTo(j.ox,j.oy); ctx.lineTo(kx,ky); ctx.strokeStyle='rgba(124,195,255,0.45)'; ctx.lineWidth=3*DPR; ctx.stroke();
  ctx.globalAlpha=0.8*j.a; ctx.beginPath(); ctx.arc(kx,ky,knobR,0,Math.PI*2); ctx.fillStyle='#7cc3ff'; ctx.shadowColor='#7cc3ff'; ctx.shadowBlur=8*DPR; ctx.fill(); ctx.restore(); }

// ===== End-of-run screen =====
function drawEndScreen(){
  const isPB = state.displayScore > state.bestScore;
  const panelW = Math.min(W*0.8, 360*DPR), panelH = 180*DPR;
  const x = (W - panelW)/2, y = (H - panelH)/2;
  ctx.save();
  ctx.globalAlpha=0.88; ctx.fillStyle='#060a14'; ctx.fillRect(0,0,W,H); ctx.globalAlpha=1;
  ctx.fillStyle='rgba(18,28,50,0.96)'; ctx.roundRect ? ctx.roundRect(x,y,panelW,panelH,10*DPR) : ctx.fillRect(x,y,panelW,panelH);
  ctx.fill();
  ctx.strokeStyle='rgba(140,180,255,0.4)'; ctx.lineWidth=2*DPR; ctx.strokeRect(x+1*DPR,y+1*DPR,panelW-2*DPR,panelH-2*DPR);

  ctx.textAlign='center';
  ctx.font=`${18*UIS*DPR}px system-ui`; ctx.fillStyle='#e6f0ff';
  ctx.fillText('Run Summary', x+panelW/2, y+20*DPR);

  ctx.font=`${14*UIS*DPR}px system-ui`; ctx.fillStyle='#bcd3ff';
  ctx.fillText('Score: '+Math.round(state.displayScore).toLocaleString(), x+panelW/2, y+52*DPR);
  ctx.fillText('Best: '+Math.round(Math.max(state.bestScore, state.displayScore)).toLocaleString(), x+panelW/2, y+74*DPR);

  if(isPB){
    ctx.font=`${13*UIS*DPR}px system-ui`; ctx.fillStyle='#9bffb0';
    ctx.fillText('NEW PERSONAL BEST!', x+panelW/2, y+100*DPR);
  }

  ctx.font=`${12*UIS*DPR}px system-ui`; ctx.fillStyle='rgba(230,240,255,0.85)';
  ctx.fillText('Tap anywhere to restart', x+panelW/2, y+panelH-24*DPR);

  ctx.restore();
}

function handleRunEnd(){
  // store best
  if(state.displayScore > state.bestScore){
    state.bestScore = Math.round(state.displayScore);
    try{ localStorage.setItem('ztap_best', String(state.bestScore)); }catch(_){}
  }
}

// ===== Boot =====
function boot(){
  resize();
  Object.assign(state, {
    time:0, shake:0, hitstop:0, score:0, displayScore:0, scorePulse:0,
    lives:3, wave:1, gameOver:false,
    lastSpawn:0, spawnDelay:650, waveTarget:12, spawned:0,
    lastShot:0, shootDelay:380, bombs:1, invuln:0,
    spreadLevel:0, hasteTimer:0,
    mult:1, multTimer:0, geomCapReached:false,
    banner:{text:'',t:0}, joy:{active:false,ox:0,oy:0,x:0,y:0,a:0,t:0},
    cometTimer: rand(8000,16000), bgPulse:0,
    combo:0, comboTimeMs:0, comboBest:0, magnet:0, tookHitThisWave:false,
    comboPulse:0, comboMilestone:0,
    overdrive:false, overdriveTimer:0, overdrivePulse:0,
    choice:{active:false, options:[], picked:null},
    bounties: [],
    magnetBoostTimer:0,
    bestScore: Number(localStorage.getItem('ztap_best')||0),
    justStarted:true,
    aug:{speedMul:1, bulletSpeedMul:1, playerSizeMul:1, comboWindowBonus:0, overdriveComboDelta:0, overdriveMsBonus:0, magnetBoost:0}
  });
  state.enemies.length=0; state.bullets.length=0; state.enemyShots.length=0; state.trails.length=0; state.floaters.length=0; state.ripples.length=0; state.particles.length=0; state.powerups.length=0; state.comets.length=0;
  player.r=16*DPR*(state.aug.playerSizeMul||1); player.speed=0.38*DPR; player.x=W/2; player.y=H/2; player.tx=player.x; player.ty=player.y;
  dropBanner('Wave 1'); spawnEnemy(); spawnEnemy(); maybeSpawnWaveChest();
  initBounties();
  if(_rafId) cancelAnimationFrame(_rafId);
  let last=performance.now();
  function loop(now){
    _rafId = requestAnimationFrame(loop);
    if(_paused){ last=now; return; }
    try{
      const dt=Math.min(50, now-last);
      last=now;
      update(dt,now);
      draw();
    }catch(err){ showError(err); }
  }
  _rafId = requestAnimationFrame(loop);
}
boot();
</script>
</body>
</html>